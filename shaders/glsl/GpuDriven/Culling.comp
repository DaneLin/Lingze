// Using compute shader to do gpu driven culling and draw command generation
#version 450

#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require

#include "Mesh.h"

// TODO: AMD wavefront size
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// uniform buffer
layout(std430,set = 0, binding = 0) uniform UboData
{
	CullData cull_data;
};

// storage buffer for meshes
layout(set = 0, binding = 1) readonly buffer MeshData
{
	Mesh meshes[];
};

// storage buffer for mesh draws
layout(set = 0, binding = 2, scalar) readonly buffer MeshDrawData
{
	MeshDraw mesh_draws[];
};

// storage buffer for draw commands
layout(set = 0, binding = 3) writeonly buffer VisibleMeshDrawCommand
{
	MeshDrawCommand draw_cmds[];
};

// storage buffer for visible mesh draw commands count
layout(set = 0, binding = 4, scalar) writeonly buffer VisibleMeshDrawCommandCount
{
	uint visible_mesh_draw_cmd_count;
};

void main()
{
    uint draw_index = gl_GlobalInvocationID.x;

    if (draw_index >= cull_data.draw_count)
    {
        return;
    }

    MeshDraw mesh_draw = mesh_draws[draw_index];
    Mesh mesh = meshes[mesh_draw.mesh_index];

    vec4 center = mesh_draw.model_matrix * vec4(mesh.sphere_bound.xyz,1.0);
    float radius = mesh.sphere_bound.w;

    bool is_visible = true;
    // the left/top/right/bottom plane culling utilizes frustum symmetry to cull against two planes at the same time
	// is_visible = is_visible && center.z * cull_data.frustum[1] - abs(center.x) * cull_data.frustum[0] > -radius;
	// is_visible = is_visible && center.z * cull_data.frustum[3] - abs(center.y) * cull_data.frustum[2] > -radius;
	// // the near/far plane culling uses camera space Z directly
	// is_visible = is_visible && center.z + radius > cull_data.znear && center.z - radius < cull_data.zfar;

    // TODO: culling
    if (is_visible)
    {
        uint draw_cmd_index = atomicAdd(visible_mesh_draw_cmd_count, 1);

        draw_cmds[draw_cmd_index].draw_index = draw_index;
        draw_cmds[draw_cmd_index].index_count = mesh.index_count;
        draw_cmds[draw_cmd_index].instance_count = 1;
        draw_cmds[draw_cmd_index].first_index = mesh.index_offset;
        draw_cmds[draw_cmd_index].vertex_offset = mesh.vertex_offset;
        draw_cmds[draw_cmd_index].first_instance = 0;
    }
}