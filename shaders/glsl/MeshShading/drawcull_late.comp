// Using compute shader to do gpu driven culling and draw command generation
#version 450

#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_GOOGLE_include_directive : require

#include "Mesh.h"
#include "../common_math.h"

layout(local_size_x = COMPUTE_WGSIZE, local_size_y = 1, local_size_z = 1) in;

// uniform buffer
layout(std430, set = 0, binding = 0) uniform UboData
{
	CullData cull_data;
};

// storage buffer for meshes
layout(set = 0, binding = 1) readonly buffer MeshData
{
	MeshInfo mesh_infos[];
};

// storage buffer for mesh draws
layout(set = 0, binding = 2, scalar) readonly buffer MeshDrawData
{
	MeshDraw mesh_draws[];
};

// storage buffer for draw commands
layout(set = 0, binding = 3) writeonly buffer VisibleMeshTaskDrawCommand
{
	MeshTaskDrawCommand draw_cmds[];
};

// storage buffer for visible mesh draw commands count
layout(std430, set = 0, binding = 4) writeonly buffer VisibleMeshTaskDrawCommandCount
{
	uint visible_mesh_task_draw_cmd_count;
};

// storage buffer for visible mesh draw commands
layout(set = 0, binding = 5) buffer DrawVisibilityBuffer
{
    uint draw_visibility[];
};

layout(set = 0, binding = 6) uniform sampler2D depth_pyramid;

void main()
{
    uint draw_index = gl_GlobalInvocationID.x;

    if (draw_index >= cull_data.draw_count)
    {
        return;
    }

    MeshDraw mesh_draw = mesh_draws[draw_index];
    MeshInfo mesh_info = mesh_infos[mesh_draw.mesh_index];

    // calculate center in view space
    vec3 center = mesh_info.sphere_bound.xyz;
    center = (cull_data.view_matrix *mesh_draw.model_matrix * vec4(center, 1.0)).xyz;
    float sphere_radius = mesh_info.sphere_bound.w;
    // calculate maximum scale to get final scale parameter
    float scale_x = length(vec3(mesh_draw.model_matrix[0][0], mesh_draw.model_matrix[0][1], mesh_draw.model_matrix[0][2]));
    float scale_y = length(vec3(mesh_draw.model_matrix[1][0], mesh_draw.model_matrix[1][1], mesh_draw.model_matrix[1][2]));
    float scale_z = length(vec3(mesh_draw.model_matrix[2][0], mesh_draw.model_matrix[2][1], mesh_draw.model_matrix[2][2]));
    float max_scale = max(max(scale_x, scale_y), scale_z);

    float radius = sphere_radius * max_scale;

    bool is_visible = true;
    // the left/top/right/bottom plane culling utilizes frustum symmetry to cull against two planes at the same time
	is_visible = is_visible && center.z * cull_data.frustum[1] - abs(center.x) * cull_data.frustum[0] > -radius;
	is_visible = is_visible && center.z * cull_data.frustum[3] - abs(center.y) * cull_data.frustum[2] > -radius;
	// the near/far plane culling uses camera space Z directly
	is_visible = is_visible && center.z + radius > cull_data.znear && center.z - radius < cull_data.zfar;

    if (is_visible)
    {
       vec4 aabb;
		if (project_sphere(center, radius, cull_data.znear, cull_data.P00, cull_data.P11, aabb))
		{
			float width = (aabb.z - aabb.x) * cull_data.depth_pyramid_width;
			float height = (aabb.y - aabb.w) * cull_data.depth_pyramid_height;

			float level = floor(log2(max(width, height)));

			// Sampler is set up to do max reduction, so this computes the maximum depth of a 2x2 texel quad
			float depth = textureLod(depth_pyramid, (aabb.xy + aabb.zw) * 0.5, level).x;
			float depthSphere = 1.0 - cull_data.znear / (center.z - radius);

			is_visible = is_visible && depthSphere <= depth;
		}
    }

    if (is_visible && draw_visibility[draw_index] == 0)
    {
        uint draw_cmd_index = atomicAdd(visible_mesh_task_draw_cmd_count, 1);

        draw_cmds[draw_cmd_index].group_count_x = (mesh_info.meshlet_count + TASK_WGSIZE - 1) / TASK_WGSIZE;
        draw_cmds[draw_cmd_index].group_count_y = 1;
        draw_cmds[draw_cmd_index].group_count_z = 1;
        draw_cmds[draw_cmd_index].meshlet_offset = mesh_info.meshlet_offset;
    }
    draw_visibility[draw_index] = is_visible ? 1 : 0;
}